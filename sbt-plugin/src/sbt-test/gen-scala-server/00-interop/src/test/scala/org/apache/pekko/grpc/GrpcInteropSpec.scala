package org.apache.pekko.grpc.interop

import org.apache.pekko.stream.{ Materializer, SystemMaterializer }
import org.apache.pekko.http.scaladsl.model._
import org.apache.pekko.http.scaladsl.model.headers.RawHeader
import org.apache.pekko.http.scaladsl.server.RouteResult.Complete
import org.apache.pekko.http.scaladsl.server.{ Directive0, Directives, Route }

import io.grpc.testing.integration.TestServiceHandlerFactory
import io.grpc.testing.integration.test.TestService
import org.scalatest.WordSpec

import scala.collection.immutable

// Generated by our plugin
import io.grpc.testing.integration.test.TestServiceHandler

class GrpcInteropIoWithAkkaSpec extends GrpcInteropTests(IoGrpcJavaServerProvider, PekkoHttpClientProviderScala)

class GrpcInteropPekkoScalaWithIoSpec extends GrpcInteropTests(PekkoHttpServerProviderScala, IoGrpcJavaClientProvider)
class GrpcInteropPekkoScalaWithAkkaSpec
    extends GrpcInteropTests(PekkoHttpServerProviderScala, PekkoHttpClientProviderScala)

class GrpcInteropPekkoJavaWithIoSpec extends GrpcInteropTests(PekkoHttpServerProviderJava, IoGrpcJavaClientProvider)
class GrpcInteropPekkoJavaWithAkkaSpec
    extends GrpcInteropTests(PekkoHttpServerProviderJava, PekkoHttpClientProviderScala)

object PekkoHttpServerProviderScala extends PekkoHttpServerProvider {
  import Directives._

  val label: String = "pekko-grpc server scala"
  val pendingCases = Set()

  val server = PekkoGrpcServerScala(implicit sys => {
    implicit val ec = sys.dispatcher

    val requestHandler = TestServiceHandler(new TestServiceImpl())

    val route: Route = (pathPrefix(TestService.name) & echoHeaders) { ctx =>
      requestHandler(ctx.request).map(Complete)
    }

    Route.toFunction(Route.seal(route))
  })

  val echoHeaders: Directive0 = extractRequest.flatMap(request => {
    val initialHeaderToEcho = request.headers.find(_.name() == "x-grpc-test-echo-initial")
    val trailingHeaderToEcho = request.headers.find(_.name() == "x-grpc-test-echo-trailing-bin")

    mapResponseHeaders(h => h ++ initialHeaderToEcho) & mapTrailingResponseHeaders(h => h ++ trailingHeaderToEcho)
  })

  // TODO to be moved to the runtime lib (or even akka-http itself?)
  def mapTrailingResponseHeaders(f: immutable.Seq[HttpHeader] => immutable.Seq[HttpHeader]): Directive0 =
    mapResponse(response =>
      response.entity match {
        case HttpEntity.Chunked(contentType, data) =>
          response.withEntity(
            HttpEntity.Chunked(
              contentType,
              data.map {
                case chunk: HttpEntity.Chunk => chunk
                case last: HttpEntity.LastChunk =>
                  HttpEntity.LastChunk(last.extension, f(last.trailer))
              }))
        case _ =>
          val origTrailers = response
            .attribute(AttributeKeys.trailer)
            .map(_.headers)
            .getOrElse(Vector.empty)
            .map(e => RawHeader(e._1, e._2))
          response.addAttribute(AttributeKeys.trailer, Trailer(f(origTrailers)))
      })
}

object PekkoHttpServerProviderJava extends PekkoHttpServerProvider {
  val label: String = "pekko-grpc server java"

  val pendingCases =
    Set(
      "custom_metadata")

  val server = new PekkoGrpcServerJava((mat, sys) => {
    TestServiceHandlerFactory.create(new JavaTestServiceImpl(mat), sys)
  })
}

object PekkoHttpClientProviderScala extends PekkoClientProvider {
  val label: String = "pekko-grpc scala client tester"

  def client = PekkoGrpcClientScala(settings => implicit sys => new PekkoGrpcClientTester(settings))
}
